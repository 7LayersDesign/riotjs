import {
  COMPONENTS_IMPLEMENTATION_MAP,
  DOM_COMPONENT_INSTANCE_PROPERTY,
  PLUGINS_SET
} from '../globals'
import {DOMattributesToObject, getName} from '../utils/dom'
import {
  autobindMethods,
  callOrAssign,
  defineDefaults,
  defineProperties,
  defineProperty,
  evaluateAttributeExpressions,
  noop,
  panic
} from '../utils/misc'
import {bindingTypes, template as createTemplate, expressionTypes} from '@riotjs/dom-bindings'
import $ from 'bianco.query'
import createSlots from './slots'
import cssManager from './css-manager'
import curry from 'curri'
import {isFunction} from '../utils/checks'

const COMPONENT_CORE_HELPERS = Object.freeze({
  // component helpers
  $(selector){ return $(selector, this.root)[0] },
  $$(selector){ return $(selector, this.root) },
  ref(selector){ return $(selector, this.root).map(el => el[DOM_COMPONENT_INSTANCE_PROPERTY] || el)}
})

const COMPONENT_LIFECYCLE_METHODS = Object.freeze({
  shouldUpdate: noop,
  onBeforeMount: noop,
  onMounted: noop,
  onBeforeUpdate: noop,
  onUpdated: noop,
  onBeforeUnmount: noop,
  onUnmounted: noop
})

const MOCKED_TEMPLATE_INTERFACE = {
  update: noop,
  mount: noop,
  unmount: noop,
  clone: noop,
  createDOM: noop
}

/**
 * Create the component interface needed for the compiled components
 * @param   {string} options.css - component css
 * @param   {Function} options.template - functon that will return the dom-bindings template function
 * @param   {Object} options.tag - component interface
 * @param   {string} options.name - component name
 * @returns {Object} component like interface
 */
export function createComponent({css, template, tag, name}) {
  return ({slots, attributes, props}) => {
    const component = defineComponent({
      css,
      template,
      tag,
      name
    })({slots, attributes, props})

    return {
      mount(element, parentScope, state) {
        return component.mount(element, state, parentScope)
      },
      update(parentScope, state) {
        return component.update(state, parentScope)
      },
      unmount() {
        return component.unmount()
      }
    }
  }
}

/**
 * Component definition function
 * @param   {Object} implementation - the componen implementation will be generated via compiler
 * @param   {Object} component - the component initial properties
 * @returns {Object} a new component implementation object
 */
export function defineComponent({css, template, tag, name}) {
  const componentAPI = callOrAssign(tag) || {}
  const components = createSubcomponents(componentAPI.components)

  // add the component css into the DOM
  if (css && name) cssManager.add(name, css)

  return curry(enhanceComponentAPI)(defineProperties(
    // set the component defaults without overriding the original component API
    defineDefaults(componentAPI, {
      ...COMPONENT_LIFECYCLE_METHODS,
      state: {}
    }), {
      // defined during the component creation
      slots: null,
      root: null,
      // these properties should not be overriden
      ...COMPONENT_CORE_HELPERS,
      css,
      template: template ? template(
        createTemplate,
        expressionTypes,
        bindingTypes,
        name => {
          return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name)
        }
      ) : MOCKED_TEMPLATE_INTERFACE
    })
  )
}

/**
 * Evaluate the component properties either from its real attributes or from its attribute expressions
 * @param   {HTMLElement} element - component root
 * @param   {Array}  attributeExpressions - attribute expressions generated by the riot compiler
 * @param   {Object} scope - current scope
 * @param   {Object} currentProps - current component properties
 * @returns {Object} attributes key value pairs
 */
function evaluateProps(element, attributeExpressions = [], scope, currentProps = {}) {
  if (attributeExpressions.length) {
    return scope ? evaluateAttributeExpressions(attributeExpressions, scope) : currentProps
  }

  return DOMattributesToObject(element)
}

/**
 * Create the bindings to update the component attributes
 * @param   {Array} attributes - list of attribute bindings
 * @returns {TemplateChunk} - template bindings object
 */
function createAttributeBindings(attributes) {
  return createTemplate(null, [{
    expressions: (attributes || []).map(attr => {
      return {
        type: expressionTypes.ATTRIBUTE,
        ...attr
      }
    })
  }])
}

/**
 * Create the subcomponents that can be included inside a tag in runtime
 * @param   {Object} components - components imported in runtime
 * @returns {Object} all the components transformed into Riot.Component factory functions
 */
function createSubcomponents(components = {}) {
  return Object.entries(callOrAssign(components))
    .reduce((acc, [key, value]) => {
      acc[key] = createComponent({ name: key, ...value })
      return acc
    }, {})
}

/**
 * Run the component instance through all the plugins set by the user
 * @param   {Object} component - component instance
 * @returns {Object} the component enhanced by the plugins
 */
function runPlugins(component) {
  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component)
}


function computeState(oldState, newState) {
  return {
    ...oldState,
    ...callOrAssign(newState)
  }
}

/**
 * Component creation factory function that will enhance the user provided API
 * @param   {Object} component - a component implementation previously defined
 * @param   {Array} options.slots - component slots generated via riot compiler
 * @param   {Array} options.attributes - attribute expressions generated via riot compiler
 * @returns {Riot.Component} a riot component instance
 */
export function enhanceComponentAPI(component, {slots, attributes, props}) {
  const attributeBindings = createAttributeBindings(attributes)

  return autobindMethods(
    runPlugins(
      defineProperties(Object.create(component), {
        mount(element, state = {}, parentScope) {
          this.props = {
            ...props,
            ...evaluateProps(element, attributes, parentScope)
          }
          this.state = computeState(this.state, state)

          defineProperties(this, {
            root: element,
            attributes: attributeBindings.createDOM(element).clone(),
            template: this.template.createDOM(element).clone()
          })

          // link this object to the DOM node
          element[DOM_COMPONENT_INSTANCE_PROPERTY] = this

          this.onBeforeMount(this.state, this.props)

          // handlte the template and its attributes
          this.attributes.mount(element, parentScope)
          this.template.mount(element, this)

          // create the slots and mount them
          defineProperty(this, 'slots', createSlots(element, slots || []))
          this.slots.mount(parentScope)

          this.onMounted(this.state, this.props)

          return this
        },
        update(state = {}, parentScope) {
          const newProps = evaluateProps(this.root, attributes, parentScope, this.props)

          if (this.shouldUpdate(newProps, this.props) === false) return

          this.props = newProps
          this.state = computeState(this.state, state)

          this.onBeforeUpdate(this.state, this.props)

          if (parentScope) {
            this.attributes.update(parentScope)
            this.slots.update(parentScope)
          }

          this.template.update(this)
          this.onUpdated(this.state, this.props)

          return this
        },
        unmount(removeRoot) {
          this.onBeforeUnmount(this.state, this.props)
          this.attributes.unmount()
          this.slots.unmount()
          this.template.unmount(this, removeRoot === true)
          this.onUnmounted(this.state, this.props)

          return this
        }
      })
    ),
    Object.keys(component).filter(prop => isFunction(component[prop]))
  )
}

/**
 * Component initialization function starting from a DOM node
 * @param   {HTMLElement} element - element to upgrade
 * @param   {Object} initialProps - initial component state
 * @param   {string} componentName - component id
 * @returns {Object} a new component instance bound to a DOM node
 */
export function mountComponent(element, initialProps, componentName) {
  const name = componentName || getName(element)
  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named "${name}" was never registered`)

  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({ props: initialProps })

  return component.mount(element)
}
