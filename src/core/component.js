import {$, $$, getAttributes, getName} from '../utils/dom'
import {COMPONENTS_CREATION_MAP, COMPONENTS_IMPLEMENTATION_MAP, DOM_COMPONENT_INSTANCE_PROPERTY, MIXINS_MAP, PLUGINS_SET} from '../globals'
import {autobindMethods, callOrAssign, defineProperties, evaluateAttributeExpressions, noop, panic} from '../utils/misc'
import {bindingTypes, template as createTemplate, expressionTypes} from '@riotjs/dom-bindings'
import cssManager from './css-manager'
import curry from 'curri'
import {isFunction} from '../utils/checks'

const COMPONENT_CORE_HELPERS = Object.freeze({
  // component helpers
  $(selector){ return $(selector, this.root) },
  $$(selector){ return $$(selector, this.root) },
  mixin(name) {
    // extend this component with this mixin
    Object.assing(this, MIXINS_MAP.get(name))
  }
})

const COMPONENT_LIFECYCLE_METHODS = Object.freeze({
  onBeforeMount: noop,
  onMounted: noop,
  onBeforeUpdate: noop,
  onUpdated: noop,
  onBeforeUnmount: noop,
  onUnmounted: noop
})

const MOCK_TEMPLATE_INTERFACE = {
  update: noop,
  mount: noop,
  unmount: noop,
  clone: noop
}

/**
 * Component definition function
 * @param   {Object} implementation - the componen implementation will be generated via compiler
 * @param   {Object} component - the component initial properties
 * @returns {Object} a new component implementation object
 */
export function defineComponent({css, template, tag, name}) {
  const componentAPI = callOrAssign(tag) || {}

  // add the component css into the DOM
  if (css && name) cssManager.add(name, css)

  return curry(createComponent)(defineProperties({
    ...COMPONENT_LIFECYCLE_METHODS,
    state: {},
    props: {},
    ...componentAPI,
    // defined during the component creation
    slots: null,
    root: null
  }, {
    // these properties should not be overriden
    ...COMPONENT_CORE_HELPERS,
    css,
    template: template ? template(
      createTemplate,
      expressionTypes,
      bindingTypes,
      function(name) {
        return (componentAPI.components || {})[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name)
      }
    ) : MOCK_TEMPLATE_INTERFACE
  }))
}

/**
 * Evaluate the component properties either from its real attributes or from its attribute expressions
 * @param   {HTMLElement} element - component root
 * @param   {Array}  attributeExpressions - attribute expressions generated by the riot compiler
 * @param   {Object} scope - current scope
 * @returns {Object} attributes key value pairs
 */
function evaluateProps(element, attributeExpressions = [], scope) {
  return attributeExpressions.length ?
    evaluateAttributeExpressions(attributeExpressions, scope) :
    getAttributes(element)
}

/**
 * Create the bindings to update the component attributes
 * @param   {Array} attributes - list of attribute bindings
 * @returns {TemplateChunk} - template bindings object
 */
function createAttributeBindings(attributes) {
  return createTemplate(null, (attributes || []).map(attr => {
    return {
      type: expressionTypes.ATTRIBUTE,
      ...attr
    }
  }))
}

/**
 * Run the component instance through all the plugins set by the user
 * @param   {Object} component - component instance
 * @returns {Object} the component enhanced by the plugins
 */
function runPlugins(component) {
  return [...PLUGINS_SET].forEach(fn => fn(component)) || component
}

/**
 * Component creation factory function
 * @param   {Object} component - a component implementation previously defined
 * @param   {Array} options.slots - component slots generated via riot compiler
 * @param   {Array} options.attributes - attribute expressions generated via riot compiler
 * @returns {Riot.Component} a riot component instance
 */
export function createComponent(component, {slots, attributes}) {
  const attributeBindings = createAttributeBindings(attributes)

  return autobindMethods(
    runPlugins(
      defineProperties(Object.create(component), {
        slots,
        mount(element, state = {}, props = {}) {
          this.props = {
            ...this.props,
            ...evaluateProps(element, attributes, props)
          }

          this.state = {
            ...this.state,
            ...callOrAssign(state)
          }

          defineProperties(this, {
            root: element,
            attributes: attributeBindings.createDOM(element).clone(),
            template: this.template.createDOM(element).clone()
          })

          // link this object to the DOM node
          element[DOM_COMPONENT_INSTANCE_PROPERTY] = this

          this.onBeforeMount()
          this.attributes.mount(element, props)
          this.template.mount(element, this)
          this.onMounted()

          return this
        },
        update(state = {}, props = {}) {
          const newProps = evaluateProps(this.root, attributes, props)

          if (this.onBeforeUpdate(newProps, state) === false) return

          this.props = {
            ...this.props,
            ...newProps
          }

          this.state = {
            ...this.state,
            ...state
          }

          this.attributes.update(props)
          this.template.update(this)
          this.onUpdated()

          return this
        },
        unmount(removeRoot) {
          this.onBeforeUnmount()
          this.attributes.unmount()
          this.template.unmount(this, removeRoot === true)
          this.onUnmounted()

          return this
        }
      })
    ),
    Object.keys(component).filter(prop => isFunction(component[prop]))
  )
}

/**
 * Component initialization function starting from a DOM node
 * @param   {HTMLElement} element - element to upgrade
 * @param   {Object} initialState - initial component state
 * @param   {string} componentName - component id
 * @returns {Object} a new component instance bound to a DOM node
 */
export function mountComponent(element, initialState, componentName) {
  const name = componentName || getName(element)
  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named "${name}" was never registered`)
  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({})
  COMPONENTS_CREATION_MAP.set(element, component)

  return component.mount(element, {}, initialState)
}
