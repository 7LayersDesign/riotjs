import {$, $$, getAttributes, getName, setAttributes} from '../utils/dom'
import {COMPONENTS_CREATION_MAP, COMPONENTS_IMPLEMENTATION_MAP, MIXINS_MAP} from '../globals'
import {bindingTypes, template as createTemplate, expressionTypes} from '@riotjs/dom-bindings'
import {callOrAssign, defineProperties, evaluateAttributeExpressions, panic} from '../utils/misc'
import curry from 'curri'

const COMPONENT_CORE = Object.freeze({
  // component helpers
  $(selector){ return $(this.root, selector) },
  $$(selector){ return $$(this.root, selector) },
  mixin(name) {
    // extend this component with this mixin
    Object.assing(this, MIXINS_MAP.get(name))
  },
  // defined during the component creation
  css: null,
  template: null
})

const COMPONENT_LIFECYCLE_METHODS = Object.freeze({
  onBeforeMount() {},
  onMounted() {},
  onBeforeUpdate() {},
  onUpdated() {},
  onBeforeUnmount() {},
  onUnmounted() {}
})

/**
 * Component definition function
 * @param   {Object} implementation - the componen implementation will be generated via compiler
 * @param   {Object} component - the component initial properties
 * @returns {Object} a new component implementation object
 */
export function defineComponent({css, template, tag}) {
  const componentAPI = callOrAssign(tag)

  const componentImplementation = defineProperties({
    ...COMPONENT_LIFECYCLE_METHODS,
    ...componentAPI,
    // defined during the component creation
    slots: null,
    state: null,
    props: null,
    root: null
  }, {
    // these properties should not be overriden
    ...COMPONENT_CORE,
    css,
    template: tag.render || template(
      createTemplate,
      bindingTypes,
      expressionTypes,
      {
        ...COMPONENTS_IMPLEMENTATION_MAP,
        ...(componentAPI.components || {})
      }
    )
  })

  return curry(createComponent)(componentImplementation, {})
}

/**
 * Evaluate the component properties either from its real attributes or from its attribute expressions
 * @param   {HTMLElement} element - component root
 * @param   {Array}  attributeExpressions - attribute expressions generated by the riot compiler
 * @param   {Object} scope - current scope
 * @returns {Object} attributes key value pairs
 */
function evaluateProps(element, attributeExpressions = [], scope) {
  return attributeExpressions.length ?
    evaluateAttributeExpressions(attributeExpressions, scope) :
    getAttributes(element)
}

/**
 * Component creation factory function
 * @param   {Object} component - a component implementation previously defined
 * @param   {Object|Function} initialState - initial component state
 * @param   {Array} options.slots - component slots generated via riot compiler
 * @param   {Array} options.attributes - attribute expressions generated via riot compiler
 * @returns {Riot.Component} a riot component instance
 */
export function createComponent(component, initialState, {slots, attributes}) {
  // if this component was manually mounted its DOM attributes are likely not attribute expressions
  // generated via riot compiler
  const shouldSetAttributes = attributes && attributes.length

  return defineProperties(Object.create(component), {
    slots,
    state: callOrAssign(initialState),
    props: {},
    mount(element, scope, state = {}) {
      defineProperties(this, {
        props: evaluateProps(element, attributes, scope),
        state: {
          ...this.state,
          ...state
        },
        root: element
      })

      this.onBeforeMount()
      shouldSetAttributes && setAttributes(this.root, this.props)
      this.template.mount(element, this)
      this.onMounted()
    },
    update(scope, state = {}) {
      const newProps = evaluateProps(this.root, attributes, scope)

      if (this.onBeforeUpdate(newProps, state) === false) return
      defineProperties(this, {
        props: {
          ...this.props,
          ...newProps
        },
        state: {
          ...this.state,
          ...state
        }
      })

      shouldSetAttributes && setAttributes(this.root, this.props)
      this.template.update(this)
      this.onUpdated()
    },
    unmount() {
      this.onBeforeUnmount()
      this.template.unmount()
      this.onUnmounted()
    }
  })
}

/**
 * Component initialization function starting from a DOM node
 * @param   {HTMLElement} element - element to upgrade
 * @param   {string} componentName - component id
 * @param   {Object} initialState - initial component state
 * @returns {Object} a new component instance bound to a DOM node
 */
export function mountComponent(element, componentName, initialState) {
  const name = componentName || getName(element)
  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named "${name}" was never registered`)
  const component = createComponent(
    COMPONENTS_IMPLEMENTATION_MAP.get(name),
    initialState,
    {}
  )
  COMPONENTS_CREATION_MAP.set(element, component)

  // wrapper around the default component API
  // in this case the component was mounted manually
  return {
    mount(element, state) {
      return component.mount(element, {}, state)
    },
    update(state) {
      return component.update(element, {}, state)
    },
    unmount() {
      return component.unmount()
    }
  }
}
